---
title: 
  "Workshop 02 Solution: Conversion and reactor sizing"
date: 2024-03-03
last-modified: 2024-04-16
format: 
   html: default
   pdf:
      output-file: "workshop-02-solution-conversion-and-reactor-sizing"
      output-ext: "pdf"
resources:
  - "./workshop-02-problem-1-data.csv"
---

```{python}
import numpy as np
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
from scipy import stats
import scipy.interpolate as interpolate
import scipy.integrate as integrate
from tabulate import tabulate
from IPython.display import display, Markdown
plt.style.use('../../../assets/templates/publish.mplstyle')
```

## Problem 1

**P2-3**: You have two CSTRs and two PFRs, each with a volume of $1.6 m^3$ . Use [@fig-2-2b] to calculate the conversion for each of the reactors in the following arrangements.

(a) Two CSTRs in series.
(b) Two PFRs in series.
(c) Two CSTRs in parallel with the feed, $F_{A0}$, divided equally between the two reactors.
(d) Two PFRs in parallel with the feed divided equally between the two reactors.
(e) A CSTR and a PFR in parallel with the flow equally divided. Calculate the overall conversion, $X_{ov}$

$$
X_{ov} = \frac{F_{A0}-F_{A,CSTR} - F_{A,PFR}}{F_{A0}}
$$
with
$$
F_{A,CSTR} = \frac{F_{A0}}{2} - \frac{F_{A0}}{2} X_{CSTR}
, \text{and }
F_{A,PFR} = \frac{F_{A0}}{2} (1 -  X_{PFR})
$$

(f) A PFR followed by a CSTR.
(g) A CSTR followed by a PFR. 
(h) A PFR followed by two CSTRs. Is this arrangement a good arrangement or is there a better one?

::: {.content-visible when-format="html"}

![Figure-2-2b](../../../assets/images/fig-2-2b.png){#fig-2-2b width=70%}

:::

::: {.content-visible unless-format="html"}

![Figure-2-2b](../../../assets/images/fig-2-2b.png){#fig-2-2b}

:::


**Solution**:

To read the CSV file use the
[`genfromtxt`](https://numpy.org/doc/stable/reference/generated/numpy.genfromtxt.html)
function from `numpy` 

```python
import numpy as np

p1_expt_file = './workshop-02-problem-1-data.csv'
p1_expt_data = np.genfromtxt(p1_expt_file, 
                             delimiter=',', 
                             dtype=[('x', float), 
                                    ('fa0_by_ra', float)], 
                             skip_header=1)
```

To interpolate the data, use
[`CubicSpline`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.CubicSpline.html#scipy.interpolate.CubicSpline)
function from [`scipy.interpolate`](https://docs.scipy.org/doc/scipy/reference/interpolate.html).

```python
import scipy.interpolate as interpolate

p1_interp = interpolate.CubicSpline(p1_expt_data['x'], 
                                    p1_expt_data_data['fa0_by_ra'])
```

Data plotting using [`matplotlib.pyplot`](https://matplotlib.org/stable/api/pyplot_summary.html)

```python
import matplotlib.pyplot as plt

fig,ax = plt.subplots()

ax.scatter(p1_expt_data['x'], 
           p1_expt_data['fa0_by_ra'], 
           marker='s', 
           color='red')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 12)

plt.show()
```

Add fit line to the plot

```python
x_interp =np.linspace(0,1,100)
ax.plot(x_interp, p1_interp(x_interp), color='grey')
```

Add rectangle to the plot

```python

# Adds rectangle from (0,0) with a width of x1 and height of y1
rectangle = plt.Rectangle((0, 0), x1, y1, color='skyblue', alpha=0.4)
ax.add_patch(rectangle)
```

Color area under the curve

```python

 Fill the area under the curve between x1 and x2
x_fill = np.linspace(x1, x2, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='skyblue', alpha=0.4)
```

```{python}

p1_expt_file = './workshop-02-problem-1-data.csv'
p1_fit_file = './workshop-02-problem-1-fit.csv'

p1_expt_data = np.genfromtxt(p1_expt_file, 
                             delimiter=',', 
                             dtype=[('x', float), 
                                    ('y', float)], 
                             skip_header=1)

p1_fit_data = np.genfromtxt(p1_fit_file, 
                            delimiter=',', 
                            dtype=[('x', float), 
                                   ('y', float)], 
                            skip_header=1)

# Interpolate using cubic spline 
p1_interp = interpolate.CubicSpline(p1_fit_data['x'], p1_fit_data['y'])

# Function to calculate the conversion in a CSTR for given volume
def CSTR_Volume_Coordinates(curve_interp, 
                            target_volume, 
                            x_start=0, 
                            x_end=1, 
                            steps=1000, 
                            *args): 

   for x in np.linspace(x_start, x_end, steps):

      # Avoid division by zero
      if x == x_start:
         continue
      
      fa0_by_ra_target = target_volume/ (x-x_start)
      fa0_by_ra_actual = curve_interp(x, *args)

      if fa0_by_ra_target <= fa0_by_ra_actual:
         return x, fa0_by_ra_target

   # If no valid volume is found within given range, return None. 
   return None, None

# Function to calculate the conversion in a PFR for a given volume
def PFR_Volume_Coordinates(curve_interp, 
                           target_volume, 
                           x_start=0, 
                           x_end=1, 
                           steps=1000, 
                           *args): 

   for x in np.linspace(x_start, x_end, steps):

      # Avoid division by zero
      if x == x_start:
         continue

      fa0_by_ra_actual = curve_interp(x, *args)
      actual_volume, err = integrate.quad(curve_interp, x_start, x, args=args)

      if actual_volume >= target_volume:
         return x, fa0_by_ra_actual

   # If no valid volume is found within given range, return None. 
   return None, None


```

```{python}
#| label: fig-problem-1
#| fig-cap: Levenspiel plot of processed data 2 for problem 2-2b

fig,ax = plt.subplots()

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')


ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 12)

plt.show()

```

(a) Two CSTRs in series (@fig-problem-1-a). 

```{python}
#| label: fig-problem-1-a
#| fig-cap: Conversion from two CSTR in series

fig,ax = plt.subplots()

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# CSTR 1
target_x_1, target_fa0_by_ra_1 = CSTR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

rectangle = plt.Rectangle((0, 0), target_x_1, target_fa0_by_ra_1, color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_1$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.5, text_str, ha='center', va='bottom')

# CSTR 2
target_x_2, target_fa0_by_ra_2 = CSTR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

rectangle = plt.Rectangle((target_x_1, 0), (target_x_2-target_x_1), target_fa0_by_ra_2, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_2$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2) / 2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 12)

plt.show()

```

(b) Two PFRs in series (@fig-problem-1-b).

```{python}
#| label: fig-problem-1-b
#| fig-cap: Conversion from two PFR in series

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(x_interp, p1_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# PFR 1
target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='skyblue', alpha=0.4)

text_str = r"""$X_1$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.5, text_str, ha='center', va='bottom')

# PFR 2
target_x_2, target_fa0_by_ra_2 = PFR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(target_x_1, target_x_2, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightcoral', alpha=0.4)

text_str = r"""$X_2$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2) / 2, 0.5, text_str, ha='center', va='bottom')


ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 14)

plt.show()

```

(c) Two CSTRs in parallel with the feed, $F_{A0}$, divided equally between the two reactors (@fig-problem-1-c).


```{python}
#| label: fig-problem-1-c
#| fig-cap: Conversion from two CSTR in parallel

fig,ax = plt.subplots()

ax.scatter(p1_expt_data['x'], p1_expt_data['y']/2, marker='s', color='red')
ax.plot(p1_fit_data['x'], p1_fit_data['y']/2, color='black')


# Interpolate using cubic spline 
p1c_interp = interpolate.CubicSpline(p1_fit_data['x'], p1_fit_data['y']/2)

# CSTR 1 and 2
target_x_1, target_fa0_by_ra_1 = CSTR_Volume_Coordinates(p1c_interp, 1.6, 0, 1)

rectangle = plt.Rectangle((0, 0), target_x_1, target_fa0_by_ra_1, color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_1, X_2$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.25, text_str, ha='center', va='bottom')
ax.text(target_x_1/2, target_fa0_by_ra_1, '$V_1$, and $V_2$', ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{1}{2}\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 12/2)

plt.show()

```


(d) Two PFRs in parallel with the feed divided equally between the two reactors (@fig-problem-1-d).

```{python}
#| label: fig-problem-1-d
#| fig-cap: Conversion from two PFR in parallel

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

# Interpolate using cubic spline 
p1d_interp = interpolate.CubicSpline(p1_fit_data['x'], p1_fit_data['y']/2)


ax.scatter(p1_expt_data['x'], p1_expt_data['y']/2, marker='s', color='red')
ax.plot(x_interp, p1d_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y']/2, color='black')

# PFR 1 and 2
target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(p1d_interp, 1.6, 0, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = p1d_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='skyblue', alpha=0.4)

text_str = r"""$X_1, X_2$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.25, text_str, ha='center', va='bottom')
ax.text(target_x_1/2, 2, '$V_1$, and $V_2$', ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{1}{2}\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 14/2)

plt.show()

```


(e) A CSTR and a PFR in parallel with the flow equally divided. Calculate the
    overall conversion, $X_{ov}$ (@fig-problem-1-e)

```{python}
#| label: fig-problem-1-e
#| fig-cap: Conversion from a CSTR and a PFR in parallel

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

# Interpolate using cubic spline 
p1e_interp = interpolate.CubicSpline(p1_fit_data['x'], p1_fit_data['y']/2)


ax.scatter(p1_expt_data['x'], p1_expt_data['y']/2, marker='s', color='red')
ax.plot(x_interp, p1e_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y']/2, color='black')

# CSTR 
target_x_1, target_fa0_by_ra_1 = CSTR_Volume_Coordinates(p1e_interp, 1.6, 0, 1)

xc = target_x_1

rectangle = plt.Rectangle((0, 0), target_x_1, target_fa0_by_ra_1, color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_1)
ax.text(0.2, 2.0, text_str, ha='center', va='bottom')

# PFR
target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(p1e_interp, 1.6, 0, 1)

xp = target_x_1

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = p1e_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightcoral', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_1)
ax.text(0.8, 0.25, text_str, ha='center', va='bottom')


text_str = r"""Overall Conversion: $X_O = \frac{{X_C + X_P}}{{2}}$ = {x:.2f}""".format(x= (xc+xp)/2)
ax.text(0.5, 6, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{1}{2}\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 14/2)

plt.show()

```

(f) A PFR followed by a CSTR (@fig-problem-1-f).

```{python}
#| label: fig-problem-1-f
#| fig-cap: Conversion from a PFR followed by CSTR

fig,ax = plt.subplots()

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(x_interp, p1_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# PFR
target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.5, text_str, ha='center', va='bottom')



# CSTR 
target_x_2, target_fa0_by_ra_2 = CSTR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

rectangle = plt.Rectangle((target_x_1, 0), (target_x_2-target_x_1), target_fa0_by_ra_2, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2) / 2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 12)

plt.show()

```


(g) A CSTR followed by a PFR (@fig-problem-1-g). 


```{python}
#| label: fig-problem-1-g
#| fig-cap: Conversion from a CSTR followed by PFR

fig,ax = plt.subplots()

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# CSTR
target_x_1, target_fa0_by_ra_1 = CSTR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

rectangle = plt.Rectangle((0, 0), target_x_1, target_fa0_by_ra_1, color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_1$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.5, text_str, ha='center', va='bottom')

# PFR
target_x_2, target_fa0_by_ra_2 = PFR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(target_x_1, target_x_2, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightcoral', alpha=0.4)

text_str = r"""$X_2$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2) / 2, 0.5, text_str, ha='center', va='bottom')


ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 12)

plt.show()

```


(h) A PFR followed by two CSTRs (@fig-problem-1-h). Is this arrangement a good arrangement or is there a better one?

```{python}
#| label: fig-problem-1-h
#| fig-cap: Conversion from a PFR followed by two CSTRs

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(x_interp, p1_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# PFR
target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.5, text_str, ha='center', va='bottom')


# CSTR 1
target_x_2, target_fa0_by_ra_2 = CSTR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

rectangle = plt.Rectangle((target_x_1, 0), (target_x_2-target_x_1), target_fa0_by_ra_2, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2) / 2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# CSTR 2
target_x_3, target_fa0_by_ra_3 = CSTR_Volume_Coordinates(p1_interp, 1.6, target_x_2, 1)

rectangle = plt.Rectangle((target_x_2, 0), (target_x_3-target_x_2), target_fa0_by_ra_3, color='yellowgreen', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_{{C2}}$ = {x:.2f}""".format(x=target_x_3)
ax.text((target_x_2 + target_x_3) / 2, 2, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 20)

plt.show()

```


```{python}
#| label: fig-problem-1-h2
#| fig-cap: Conversion from two CSTRs followed by a PFR

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(x_interp, p1_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# CSTR 1
target_x_1, target_fa0_by_ra_1 = CSTR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

rectangle = plt.Rectangle((0,0), target_x_1, target_fa0_by_ra_1, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1 / 2, 0.5, text_str, ha='center', va='bottom')

# CSTR 2
target_x_2, target_fa0_by_ra_2 = CSTR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

rectangle = plt.Rectangle((target_x_1, 0), (target_x_2-target_x_1), target_fa0_by_ra_2, color='yellowgreen', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_{{C2}}$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_2 + target_x_1) / 2, 2, text_str, ha='center', va='bottom')

# PFR
target_x_3, target_fa0_by_ra_3 = PFR_Volume_Coordinates(p1_interp, 1.6, target_x_2, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(target_x_2, target_x_3, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_3)
ax.text((target_x_3+target_x_2)/2, 0.5, text_str, ha='center', va='bottom')


ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 20)

plt.show()

```
Two CSTRs followed by a PFR (@fig-problem-1-h2) yield final conversion of $X_3$
= `{python} "{x:.2f}".format(x=target_x_3)`.

```{python}
#| label: fig-problem-1-h3
#| fig-cap: Conversion from two PFRs followed by a CSTR

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

ax.scatter(p1_expt_data['x'], p1_expt_data['y'], marker='s', color='red')
ax.plot(x_interp, p1_interp(x_interp), color='grey')
ax.plot(p1_fit_data['x'], p1_fit_data['y'], color='black')

# PFR
target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(p1_interp, 1.6, 0, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 0.5, text_str, ha='center', va='bottom')


# PFR 2
target_x_2, target_fa0_by_ra_2 = PFR_Volume_Coordinates(p1_interp, 1.6, target_x_1, 1)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(target_x_1, target_x_2, 100)
y_fill = p1_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1+target_x_2)/2, 0.5, text_str, ha='center', va='bottom')

# CSTR 2
target_x_3, target_fa0_by_ra_3 = CSTR_Volume_Coordinates(p1_interp, 1.6, target_x_2, 1)

rectangle = plt.Rectangle((target_x_2, 0), (target_x_3-target_x_2), target_fa0_by_ra_3, color='yellowgreen', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_{{C2}}$ = {x:.2f}""".format(x=target_x_3)
ax.text((target_x_2 + target_x_3) / 2, 2, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (m^3)$')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 30)

plt.show()

```

Two PFRs followed by a CSTR (@fig-problem-1-h3) yield final conversion of $X_3$
= `{python} "{x:.2f}".format(x=target_x_3)`.


## Problem 2

**P2-4**: The exothermic reaction of stillbene (A) to form the economically
important trospophene (B) and methane (C), i.e.,

$$\ce{A -> B + C}$$

was carried out adiabatically and the following data recorded:

| X   | $-r_A (mol/dm^3 min)$ |
|-----|------------------|
| 0   | 1                |
| 0.2 | 1.67             |
| 0.4 | 5                |
| 0.45| 5                |
| 0.5 | 5                |
| 0.6 | 5                |
| 0.8 | 1.25             |
| 0.9 | 0.91             |

: Problem 2.4 rate data {#tbl-2-4}

   The entering molar flow rate of A was $300 mol/min$.

   (a) What are the PFR and CSTR volumes necessary to achieve 40% conversion? 
   (b) Over what range of conversions would the CSTR and PFR reactor volumes be identical?
   (c) What is the maximum conversion that can be achieved in a $105 dm^3$ CSTR?
   (d) What conversion can be achieved if a $72 dm^3$ PFR is followed in series by a $24 dm^3$ CSTR?
   (e) What conversion can be achieved if a $24 dm^3$ CSTR is followed in a series by a $72 dm^3$ PFR?
   (f) Plot the conversion and rate of reaction as a function of PFR reactor volume up to a volume of $100 dm^3$.

**Solution**:

The rate data ($-r_A$) is given. We need $F_{A0}/-r_A$. Dividing $F_{A0} = 300$ by $-r_A$ we get:

```{python}
#| echo: false
#| label: tbl-problem-2
#| tbl-cap: Processed data for problem 2

p2_data_file = './workshop-02-problem-2.csv'

data = np.genfromtxt(p2_data_file, delimiter=',', dtype=[('x', float), ('minus_ra', float)], skip_header=1)

fa0_p2 = 300

ndtype = np.dtype(data.dtype.descr + [('fa0_by_minus_ra', float)])
nd = np.zeros(data.shape, dtype=ndtype)
for name in data.dtype.names:
    nd[name] = data[name] 
nd['fa0_by_minus_ra'] = fa0_p2/data['minus_ra']

p2_data = nd

# Calculate slopes of the segments
# For segment 1 (0 to 0.4)
k1 = (p2_data['fa0_by_minus_ra'][2] - p2_data['fa0_by_minus_ra'][0]) / (p2_data['x'][2] - p2_data['x'][0])

# For segment 2 (0.4 to 0.6)
k2 = 0 

# For segment 3 (0.6 to 0.9)
k3 = (p2_data['fa0_by_minus_ra'][7] - p2_data['fa0_by_minus_ra'][5]) / (p2_data['x'][7] - p2_data['x'][5])

bending_point = [
    (p2_data['x'][2], p2_data['fa0_by_minus_ra'][2]),  # Point between segment 1 and 2
    (p2_data['x'][5], p2_data['fa0_by_minus_ra'][5])   # Point between segment 2 and 3
]

x0_1, y0_1 = bending_point[0]
x0_2, y0_2 = bending_point[1]
x0 =[x0_1, x0_2]
y0 = [y0_1, y0_2]

# Function arguments
args = (x0, y0, k1, k2, k3)

p2_df = pd.DataFrame(p2_data)
p2_df.columns = ['$X$', '$-r_A$', '$F_{A0}/-r_A$']

# Convert the DataFrame to a markdown table string
markdown_table = p2_df.to_markdown(index=False)

Markdown(markdown_table)
```

```{python}
#| label: fig-problem-2
#| fig-cap: Levenspiel plot of processed data for problem 2-4

# Interpolate using cubic spline 
p2_interp = interpolate.CubicSpline(p2_data['x'], p2_data['fa0_by_minus_ra'])

fig,ax = plt.subplots()

x_interp =np.linspace(0,1,100)

ax.scatter(p2_data['x'], p2_data['fa0_by_minus_ra'], marker='s', color='red')
ax.plot(x_interp, p2_interp(x_interp), color='grey')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (dm^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 450)

plt.show()

```

Trying to fit a single cubic spline or a polynomial doesn't work well due to
the nature of the data (@fig-problem-2). The data consists of three liniear
segments. Therefore, we fit a piecewise linear function using
[`numpy.piecewise`](https://numpy.org/doc/stable/reference/generated/numpy.piecewise.html). 
We also use [`lambda`](https://www.w3schools.com/python/python_lambda.asp)
functions to define the linear segments. 

```python
def piecewise_linear_fit(x, x0, y0, k1, k2, k3):
    """
    Piecewise linear function defined by slopes and a constant part.
    x0, y0: Coordinates of the piecewise function's bending points.
    k1, k2, k3: Slopes of the first, second, and third parts.

    Note that in this problem, 
    k1 = `{python} k1`
    k2 = `{python} k2` 
    k3 = `{python} k3` 

    x0 = `{python} x0`
    y0 = `{python} y0`

    We can call this function as
    piecewise_linear_fit(x, *args)
    
    args = `{python} args`
    """

    return np.piecewise(x, 
                        [x < x0[0], (x >= x0[0]) & (x <= x0[1]), x > x0[1]], 
                        [lambda x: k1*x + y0[0] - k1*x0[0], 
                         lambda x: y0[1], 
                         lambda x: k3*x + y0[1] - k3*x0[1]])
```

```{python}
def piecewise_linear_fit(x, x0, y0, k1, k2, k3):
    """
    Piecewise linear function defined by slopes and a constant part.
    x0, y0: Coordinates of the piecewise function's bending points.
    k1, k2, k3: Slopes of the first, second, and third parts.
    """

    return np.piecewise(x, 
                        [x < x0[0], (x >= x0[0]) & (x <= x0[1]), x > x0[1]], 
                        [lambda x: k1*x + y0[0] - k1*x0[0], 
                         lambda x: y0[1], 
                         lambda x: k3*x + y0[1] - k3*x0[1]])


```

```{python}
#| label: fig-problem-2-linfit
#| fig-cap: Piecewise linear fit processed data for problem 2-4

fig,ax = plt.subplots()

x_plf =np.linspace(0,1,100)

ax.scatter(p2_data['x'], p2_data['fa0_by_minus_ra'], marker='s', color='red')
ax.plot(x_plf, piecewise_linear_fit(x_plf, *args), color='grey')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (dm^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 450)

plt.show()

```

(a) What are the PFR and CSTR volumes necessary to achieve 40% conversion? 

```{python}
#| label: fig-problem-2a
#| fig-cap: Reactor volume for CSTR to achieve X = 0.4

fig,ax = plt.subplots()

x_plf =np.linspace(0,1,100)

ax.scatter(p2_data['x'], p2_data['fa0_by_minus_ra'], marker='s', color='red')
ax.plot(x_plf, piecewise_linear_fit(x_plf, *args), color='grey')

# CSTR
fa0_by_minus_ra_1 = piecewise_linear_fit(0.4, *args)
v_cstr = 0.4 * fa0_by_minus_ra_1
rectangle = plt.Rectangle((0, 0), 0.4, fa0_by_minus_ra_1, color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$V_{{CSTR}}$ = {v:.2f}""".format(v=v_cstr)
ax.text(0.2, 10, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (dm^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 450)

plt.show()
```
    From @fig-problem-2a, $V_{CSTR}$ = `{python} r"""{v:.2f} $dm^3$""".format(v=v_cstr)`.

(b) Over what range of conversions would the CSTR and PFR reactor volumes be identical?

    As the slope of $F_{A0}/-r_A vs.\ X$ line is 0 between 0.4 and 0.6, the
    CSTR and PFR volumes over this range would be identical.


(c) What is the maximum conversion that can be achieved in a $105 dm^3$ CSTR?

```{python}
#| label: fig-problem-2c
#| fig-cap: Reactor conversion for CSTR with volume = 105 $dm^3$ 

fig,ax = plt.subplots()

x_plf =np.linspace(0,1,100)

ax.scatter(p2_data['x'], p2_data['fa0_by_minus_ra'], marker='s', color='red')
ax.plot(x_plf, piecewise_linear_fit(x_plf, *args), color='grey')

# CSTR
target_x_1, target_fa0_by_ra_1 = CSTR_Volume_Coordinates(piecewise_linear_fit, 105, 0, 1, 1000, *args)
rectangle = plt.Rectangle((0,0), target_x_1, target_fa0_by_ra_1, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1 / 2, 10, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (dm^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 450)

plt.show()
```

From @fig-problem-2c, $X$ = `{python} r"""{x:.2f}""".format(x=target_x_1)`.


(d) What conversion can be achieved if a $72 dm^3$ PFR is followed in series by a $24 dm^3$ CSTR?

```{python}
#| label: fig-problem-2d
#| fig-cap: Reactor conversion for PFR followed by CSTR

fig,ax = plt.subplots()

x_plf =np.linspace(0,1,100)

ax.scatter(p2_data['x'], p2_data['fa0_by_minus_ra'], marker='s', color='red')
ax.plot(x_plf, piecewise_linear_fit(x_plf, *args), color='grey')

# PFR 

target_x_1, target_fa0_by_ra_1 = PFR_Volume_Coordinates(piecewise_linear_fit, 72, 0, 1, 1000, *args)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, target_x_1, 100)
y_fill = piecewise_linear_fit(x_fill,*args)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_1)
ax.text(target_x_1/2, 10, text_str, ha='center', va='bottom')

# CSTR
target_x_2, target_fa0_by_ra_2 = CSTR_Volume_Coordinates(piecewise_linear_fit, 24, target_x_1, 1, 1000, *args)
rectangle = plt.Rectangle((target_x_1,0), target_x_2-target_x_1, target_fa0_by_ra_2, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2) / 2, 10, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (dm^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 450)

plt.show()
```

From @fig-problem-2d, $X_{PFR}$ = `{python} r"""{x:.2f}""".format(x=target_x_1)` and 
$X_{CSTR}$ = `{python} r"""{x:.2f}""".format(x=target_x_2)`. 


(e) What conversion can be achieved if a $24 dm^3$ CSTR is followed in a series by a $72 dm^3$ PFR?

```{python}
#| label: fig-problem-2e
#| fig-cap: Reactor conversion for CSTR followed by PFR

fig,ax = plt.subplots()

x_plf =np.linspace(0,1,100)

ax.scatter(p2_data['x'], p2_data['fa0_by_minus_ra'], marker='s', color='red')
ax.plot(x_plf, piecewise_linear_fit(x_plf, *args), color='grey')

# CSTR
target_x_1 = 0.4
target_fa0_by_ra_1 = piecewise_linear_fit(target_x_1, *args)
v_cstr = target_x_1 * target_fa0_by_ra_1
rectangle = plt.Rectangle((0, 0), target_x_1, target_fa0_by_ra_1, color='lightcoral', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$X_C$ = {x:.2f}""".format(x=target_x_1)
ax.text(0.2, 10, text_str, ha='center', va='bottom')

# PFR 

target_x_2, target_fa0_by_ra_2 = PFR_Volume_Coordinates(piecewise_linear_fit, 72, target_x_1, 1, 1000, *args)

# Fill the area under the curve between target_x_1 and target_x_2
x_fill = np.linspace(target_x_1, target_x_2, 100)
y_fill = piecewise_linear_fit(x_fill, *args)
ax.fill_between(x_fill, y_fill, color='lightblue', alpha=0.4)

text_str = r"""$X_P$ = {x:.2f}""".format(x=target_x_2)
ax.text((target_x_1 + target_x_2)/2, 10, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r_A} (dm^3)$')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 450)

plt.show()
```

From @fig-problem-2e, $X_{CSTR}$ = `{python} r"""{x:.2f}""".format(x=target_x_1)` and 
$X_{PFR}$ = `{python} r"""{x:.2f}""".format(x=target_x_2)`. 


(f) Plot the conversion and rate of reaction as a function of PFR reactor volume up to a volume of $100 dm^3$.

To create this plot (@fig-problem-2f), we will need to calculate the volume first for all $X$ as 

$$
V = \int_0^x \frac{F_{A0}{-r_A}} dX
$$

This data is given in @tbl-problem-2f

```{python}
#| echo: false
#| label: tbl-problem-2f
#| tbl-cap: Reactor conversion and rate as function fo volume

X = p2_data['x']
ra = p2_data['minus_ra']
fa0_by_ra = p2_data['fa0_by_minus_ra']

V = np.zeros_like(X)

for i, x in enumerate(X):
   v, err = integrate.quad(piecewise_linear_fit, 0, x, args=args)
   V[i]=v


p2_df = pd.DataFrame({'V': V, 'X': X, 'RA': ra})
p2_df.columns = ['$V (dm^3)$', '$X$', '$-r_A$']

# Convert the DataFrame to a markdown table string
markdown_table = p2_df.to_markdown(index=False)

Markdown(markdown_table)

```

```{python}
#| label: fig-problem-2f
#| fig-cap: Reactor conversion and rate as function fo volume

# Plotting
plt.figure(figsize=(10, 5))

# Plot X vs. V
plt.subplot(1, 2, 1)
plt.plot(V, X, 'o-', label='X vs. V')
plt.xlabel('V $dm^3$')
plt.ylabel('X')
plt.title('X vs. V')
plt.grid(True)
plt.xlim(0,100)

# Plot ra vs. V
plt.subplot(1, 2, 2)
plt.plot(V, ra, 'o-', color='r', label='$-r_A$ vs. V')
plt.xlabel('V $dm^3$')
plt.ylabel('$-r_A$')
plt.title('$-r_A$ vs. V')
plt.grid(True)
plt.xlim(0,100)

plt.tight_layout()
plt.show()

```

## Problem 3

**P2-7**: The adiabatic exothermic irreversible gas-phase reaction

$$\ce{2A + B -> 2C}$$

is to be carried out in a ﬂow reactor for an equimolar feed of A and B. A
Levenspiel plot for this reaction is shown in [@fig-p-2-7b] .

(a) What PFR volume is necessary to achieve 50% conversion?
(b) What CSTR volume is necessary to achieve 50% conversion?
(c) What is the volume of a second CSTR added in series to the first CSTR
(Part b) necessary to achieve an overall conversion of 80%? 
(d) What PFR volume must be added to the first CSTR (Part b) to raise the
conversion to 80%?
(e) What conversion can be achieved in a $6 \times 10^4 m^3$ CSTR? In a 
$6 \times 10^4 m^3$ PFR?
(f) Think critically to critique the answers (numbers) to this problem.

::: {.content-visible when-format="html"}

![fig-p2-7b](../../../assets/images/fig-p2-7b.png){#fig-p-2-7b width=70%}

:::

::: {.content-visible unless-format="html"}

![Figure-p2-7b](../../../assets/images/fig-p2-7b.png){#fig-p-2-7b}

:::

**Solution**:



## Problem 4

**P2.10**: The curve shown in [@fig-p-2-10b] is typical of a gas-solid
catalytic exothermic reaction carried out adiabatically.

(a) Assuming that you have a ﬂuidized CSTR and a PBR containing equal
weights of catalyst, how should they be arranged for this adiabatic
reaction? Use the smallest amount of catalyst weight to achieve 80%
conversion of A.
(b) What is the catalyst weight necessary to achieve 80% conversion in a
fluidized CSTR? 
(c) What ﬂuidized CSTR weight is necessary to achieve 40% conversion?
(d) What PBR weight is necessary to achieve 80% conversion?
(e) What PBR weight is necessary to achieve 40% conversion?
(f) Plot the rate of reaction and conversion as a function of PBR catalyst
weight, W.

Additional information: FA0 = 2 mol/s.

::: {.content-visible when-format="html"}

![Figure P2-10b](../../../assets/images/fig-p2-10b.png){#fig-p-2-10b width=70%}

:::

::: {.content-visible unless-format="html"}

![Figure P2-10b](../../../assets/images/fig-p2-10b.png){#fig-p-2-10b}

:::


**Solution**:

Digitized graph: (@fig-problem-4) 

```{python}
#| label: fig-problem-4
#| fig-cap: Levenspiel plot for an adiabatic exothermic heterogeneous reaction.


p4_file = './workshop-02-problem-4.csv'
p4_data = np.genfromtxt(p4_file, delimiter=',', dtype=[('x', float), ('y', float)], skip_header=1)

# Interpolate using cubic spline 
p4_interp = interpolate.CubicSpline(p4_data['x'], p4_data['y'])

fig,ax = plt.subplots()

ax.plot(p4_data['x'], p4_data['y'], color='black')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r\'_A}$ (kg catalyst)')

# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 70)

plt.show()

```

(a) Assuming that you have a fluidized CSTR and a PBR containing equal
weights of catalyst, how should they be arranged for this adiabatic
reaction? Use the smallest amount of catalyst weight to achieve 80%
conversion of A. (@fig-problem-4a)


```{python}
#| label: fig-problem-4a
#| fig-cap: Levenspiel plot for an adiabatic exothermic heterogeneous reaction.

# find conversion at which 1/-rA is minimum

imin = np.argmin(p4_data['y'])
xmin = p4_data['x'][imin]

xmin = 0.42

cstr_cat_weight = xmin*p4_interp(xmin)

fig,ax = plt.subplots()

ax.plot(p4_data['x'], p4_data['y'], color='black')

# CSTR
rectangle = plt.Rectangle((0, 0), xmin, p4_interp(xmin), color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$W$ = {w:.2f} kg""".format(w=cstr_cat_weight)
ax.text(xmin/2, 0.5, text_str, ha='center', va='bottom')

# PFR 
target_x_2, target_fa0_by_ra_2 = PFR_Volume_Coordinates(p4_interp, cstr_cat_weight, xmin, 0.95)

# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(xmin, target_x_2, 100)
y_fill = p4_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightcoral', alpha=0.4)

text_str = r"""$X_2$ = {x:.2f}""".format(x=target_x_2)
ax.text((xmin + target_x_2) / 2, 0.5, text_str, ha='center', va='bottom')

text_str = r"""Total Catalyst Weight: W = {w:.2f} kg""".format(w= cstr_cat_weight*2)
ax.text(0.5, 60, text_str, ha='center', va='bottom')


ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r\'_A}$ (kg catalyst)')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 70)

plt.show()

```


(b) What is the catalyst weight necessary to achieve 80% conversion in a
fluidized CSTR? (@fig-problem-4b)


```{python}
#| label: fig-problem-4b
#| fig-cap: Catalyst weight for 80% conversion in CSTR 


x_cstr = 0.8
cstr_cat_weight = x_cstr*p4_interp(x_cstr)

fig,ax = plt.subplots()

ax.plot(p4_data['x'], p4_data['y'], color='black')

# CSTR
rectangle = plt.Rectangle((0, 0), x_cstr, p4_interp(x_cstr), color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$W$ = {w:.2f} kg""".format(w=cstr_cat_weight)
ax.text(xmin/2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r\'_A}$ (kg catalyst)')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 70)

plt.show()

```


(c) What fluidized CSTR weight is necessary to achieve 40% conversion? (@fig-problem-4c)


```{python}
#| label: fig-problem-4c
#| fig-cap: Catalyst weight for 40% conversion in CSTR 


x_cstr = 0.4
cstr_cat_weight = x_cstr*p4_interp(x_cstr)

fig,ax = plt.subplots()

ax.plot(p4_data['x'], p4_data['y'], color='black')

# CSTR
rectangle = plt.Rectangle((0, 0), x_cstr, p4_interp(x_cstr), color='skyblue', alpha=0.4)
ax.add_patch(rectangle)

text_str = r"""$W$ = {w:.2f} kg""".format(w=cstr_cat_weight)
ax.text(xmin/2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r\'_A}$ (kg catalyst)')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 70)

plt.show()

```


(d) What PBR weight is necessary to achieve 80% conversion? (@fig-problem-4d)


```{python}
#| label: fig-problem-4d
#| fig-cap: Catalyst weight for 80% conversion in PBR

# find conversion at which 1/-rA is minimum

xpbr = 0.8
w_pbr, err = integrate.quad(p4_interp, 0, xpbr)

fig,ax = plt.subplots()

ax.plot(p4_data['x'], p4_data['y'], color='black')

# PBR 
# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, xpbr, 100)
y_fill = p4_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightcoral', alpha=0.4)

text_str = r"""$W_{{PBR}}$ = {w:.2f} kg""".format(w = w_pbr)
ax.text(xpbr/2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r\'_A}$ (kg catalyst)')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 70)

plt.show()

```


(e) What PBR weight is necessary to achieve 40% conversion? (@fig-problem-4e)


```{python}
#| label: fig-problem-4e
#| fig-cap: Catalyst weight for 40% conversion in PBR

# find conversion at which 1/-rA is minimum

xpbr = 0.4
w_pbr, err = integrate.quad(p4_interp, 0, xpbr)

fig,ax = plt.subplots()

ax.plot(p4_data['x'], p4_data['y'], color='black')

# PBR 
# Fill the area under the curve between 0 and target_x_1
x_fill = np.linspace(0, xpbr, 100)
y_fill = p4_interp(x_fill)
ax.fill_between(x_fill, y_fill, color='lightcoral', alpha=0.4)

text_str = r"""$W_{{PBR}}$ = {w:.2f} kg""".format(w = w_pbr)
ax.text(xpbr/2, 0.5, text_str, ha='center', va='bottom')

ax.set_xlabel('Conversion X')
ax.set_ylabel('$\\frac{F_{A0}}{-r\'_A}$ (kg catalyst)')


# Setting x and y axis limits
ax.set_xlim(0, 1)
ax.set_ylim(0, 70)

plt.show()

```


(f) Plot the rate of reaction and conversion as a function of PBR catalyst
weight, W. (Data table: @tbl-problem-4f; Plots: @fig-problem-4f)

```{python}
#| label: tbl-problem-4f
#| tbl-cap: Reactor conversion and rate as function fo volume


p4X = p4_data['x']
p4fa0_by_ra = p4_data['y']
p4ra = 2/p4fa0_by_ra

V = np.zeros_like(p4X)

for i, x in enumerate(p4X):
   v, err = integrate.quad(p4_interp,0, x)
   V[i]=v

p4_df = pd.DataFrame({'V': V[::5], 'X': p4X[::5], 'RA': p4ra[::5]})
p4_df.columns = ['$V (dm^3)$', '$X$', '$-r_A$']

# Convert the DataFrame to a markdown table string
markdown_table = p4_df.to_markdown(index=False)

Markdown(markdown_table)

```

```{python}
#| label: fig-problem-4f
#| fig-cap: Reactor conversion and rate as function fo volume

# Plotting
plt.figure(figsize=(10, 5))

# Plot X vs. V
plt.subplot(1, 2, 1)
plt.plot(V, p4X, '-', label='X vs. V')
plt.xlabel('V $dm^3$')
plt.ylabel('X')
plt.title('X vs. V')
plt.grid(True)

# Plot ra vs. V
plt.subplot(1, 2, 2)
plt.plot(V, p4ra, '-', color='r', label='$-r_A$ vs. V')
plt.xlabel('V $dm^3$')
plt.ylabel('$-r_A$')
plt.title('$-r_A$ vs. V')
plt.grid(True)

plt.tight_layout()
plt.show()


```
